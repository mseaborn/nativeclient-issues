<ns0:entry xmlns:ns0="http://www.w3.org/2005/Atom" xmlns:ns1="http://schemas.google.com/g/2005" xmlns:ns2="http://schemas.google.com/projecthosting/issues/2009" ns1:etag="W/&quot;DE4DRn47eCl7ImA9WhZUEU4.&quot;">
		<ns0:id>http://code.google.com/feeds/issues/p/nativeclient/issues/1883/comments/full/3</ns0:id><ns0:author>
			<ns0:name>mseaborn@chromium.org</ns0:name><ns0:uri>/u/mseaborn@chromium.org/</ns0:uri></ns0:author><ns0:content type="html">A workaround we could implement is to use SysV shared memory instead of /dev/shm.  Although shmat() doesn't allow specifying PROT_EXEC, we can mprotect() the mapping after calling shmat().

With SysV SHM, we would need to delete the SHM object's name from the global namespace using shmctl()+IPC_RMID after mapping the memory, because otherwise we risk leaking the dyncode area if sel_ldr dies uncleanly.

The problem with doing IPC_RMID is that it makes it difficult to create new read+write mappings.  We might have to keep a read+write mapping for the whole 256MB dyncode region around for the life of the process, which wastes address space.  We *might* be able to get around this using mremap(), although it's tricky because mremap() doesn't allow us to change the offset of the mapping into the SHM segment, only the size of the mapping.

Using SysV SHM would have the benefit of allowing NaCl to work on random Linux systems where someone thought it was a good idea to lock down /dev/shm with "noexec".  I would still prefer to change Chrome OS's /dev/shm, though.</ns0:content><ns0:updated>2011-06-03T21:36:17.000Z</ns0:updated><ns0:published>2011-06-03T21:36:17.000Z</ns0:published><ns2:updates /><ns0:title>Comment 3 by mseaborn@chromium.org</ns0:title><ns0:link href="http://code.google.com/p/nativeclient/issues/detail?id=1883#c3" rel="alternate" type="text/html" /><ns0:link href="https://code.google.com/feeds/issues/p/nativeclient/issues/1883/comments/full/3" rel="self" type="application/atom+xml" /></ns0:entry>