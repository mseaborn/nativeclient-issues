<ns0:entry xmlns:ns0="http://www.w3.org/2005/Atom" xmlns:ns1="http://schemas.google.com/g/2005" xmlns:ns2="http://schemas.google.com/projecthosting/issues/2009" ns1:etag="W/&quot;CEENR347eCl7ImA9WhVXGUg.&quot;">
		<ns0:id>http://code.google.com/feeds/issues/p/nativeclient/issues/2742/comments/full/1</ns0:id><ns0:author>
			<ns0:name>b...@google.com</ns0:name><ns0:uri>/u/105821748722532785568/</ns0:uri></ns0:author><ns0:content type="html">To add context, NaClDesc subclass wraps an interruptible mutex object that is implemented on top of this, so the error mapping that is missing here wasn't exposed to application code.  The reason we had an interruptible mutex is because we thought we wanted to handle mmap race on Windows by moving the entire untrusted address space -- heavy lifting! -- and so all blocking syscalls need to be interruptible so in addition to stopping untrusted threads we'd be able to interrupt trusted threads to make sure they are in a safe state.  We didn't do this.  However, we cannot trivially remove interruptible mutexes because they provide deadlock detection and double unlock error detection possible, and the "native", barely abstracted mutex doesn't do that.

This issue is to ensure that if other trusted code use the NaClMutex class, it can rely on properly abstracted / mapped return status.</ns0:content><ns0:updated>2012-04-20T20:11:36.000Z</ns0:updated><ns0:published>2012-04-20T20:11:36.000Z</ns0:published><ns2:updates>
			<ns2:status>Accepted</ns2:status></ns2:updates><ns0:title>Comment 1 by b...@google.com</ns0:title><ns0:link href="http://code.google.com/p/nativeclient/issues/detail?id=2742#c1" rel="alternate" type="text/html" /><ns0:link href="https://code.google.com/feeds/issues/p/nativeclient/issues/2742/comments/full/1" rel="self" type="application/atom+xml" /></ns0:entry>