<ns0:entry xmlns:ns0="http://www.w3.org/2005/Atom" xmlns:ns1="http://schemas.google.com/g/2005" xmlns:ns2="http://schemas.google.com/projecthosting/issues/2009" ns1:etag="W/&quot;CE4CR347eCl7ImA9WhBVEks.&quot;">
		<ns0:id>http://code.google.com/feeds/issues/p/nativeclient/issues/3360/comments/full/7</ns0:id><ns0:author>
			<ns0:name>dschuff@chromium.org</ns0:name><ns0:uri>/u/dschuff@chromium.org/</ns0:uri></ns0:author><ns0:content type="html">A couple of comments:
wrt the example given: what happens if you don't use -O1 to clang? Do you get i40 in every case? I'm wondering if it's clang or maybe instcombine (or some other optimization) that has the different behavior. I can check on that tomorrow. maybe try adding i64 as a legal (aka native) integer size in the datalayout, to see if that is what affects it (although that may result in other suboptimal choices by the optimizers... but last time I checked there didn't seem to be especially heavy use of that).

Also the counterargument would be the same that led us to think about doing a pass in the first place, i.e. having to worry less about the behavior of the optimizers. e.g. SROA can generate code from struct or array allocas of particular sizes that looks very much like the bitfield example. I did figure out how to disable that (although I never actually landed it). I have a partially working pass in progress that does some of this so we should know more soon about how bad it is.</ns0:content><ns0:updated>2013-04-18T05:29:26.000Z</ns0:updated><ns0:published>2013-04-18T05:29:26.000Z</ns0:published><ns2:updates /><ns0:title>Comment 7 by dschuff@chromium.org</ns0:title><ns0:link href="http://code.google.com/p/nativeclient/issues/detail?id=3360#c7" rel="alternate" type="text/html" /><ns0:link href="https://code.google.com/feeds/issues/p/nativeclient/issues/3360/comments/full/7" rel="self" type="application/atom+xml" /></ns0:entry>