<ns0:entry xmlns:ns0="http://www.w3.org/2005/Atom" xmlns:ns1="http://schemas.google.com/g/2005" xmlns:ns2="http://schemas.google.com/projecthosting/issues/2009" ns1:etag="W/&quot;CkUCQH47eCl7ImA9Wx5XFU0.&quot;">
		<ns0:id>http://code.google.com/feeds/issues/p/nativeclient/issues/506/comments/full/12</ns0:id><ns0:author>
			<ns0:name>b...@google.com</ns0:name><ns0:uri>/u/105821748722532785568/</ns0:uri></ns0:author><ns0:content type="html">the entire dynamic code region is supposed to (also) be halt filled.  we may (later) use mprotect/VirtualProtect to leave it zero-filled to reduce RAM / swap pressure, but currently this is the case.  this is a requirement because the dynamic code region is executable -- in the x86-32 case, it is within the code segment; in the x86-64 or arm case, it contains potential control flow transfer targets due to our data-dependent control flow masking -- and unless it is halt filled (or some other innocuous instruction) then we may run into problems with our sandboxing (completely filling with halts is overkill, yes).

but in any case, sel_ldr should never crash in trusted code.  this probably means that we probably need to re-do the ELF fuzzing (that code has bitrotted and has been removed) that we had when we built sel_ldr for x86-32 to ensure that all the recent changes hasn't introduced any security problems.

i'm going to tag this with the security label until we know for sure that it isn't, and file another issue for ELF fuzzing.</ns0:content><ns0:updated>2010-09-14T21:37:41.000Z</ns0:updated><ns0:published>2010-09-14T21:37:41.000Z</ns0:published><ns2:updates>
			<ns2:label>-Pri-2</ns2:label><ns2:label>Pri-1</ns2:label><ns2:label>Security</ns2:label></ns2:updates><ns0:title>Comment 12 by b...@google.com</ns0:title><ns0:link href="http://code.google.com/p/nativeclient/issues/detail?id=506#c12" rel="alternate" type="text/html" /><ns0:link href="https://code.google.com/feeds/issues/p/nativeclient/issues/506/comments/full/12" rel="self" type="application/atom+xml" /></ns0:entry>