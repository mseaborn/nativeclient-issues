<ns0:entry xmlns:ns0="http://www.w3.org/2005/Atom" xmlns:ns1="http://schemas.google.com/g/2005" xmlns:ns2="http://schemas.google.com/projecthosting/issues/2009" ns1:etag="W/&quot;CU4EQn47eCl7ImA9WhdXFks.&quot;">
		<ns0:id>http://code.google.com/feeds/issues/p/nativeclient/issues/2207/comments/full/2</ns0:id><ns0:author>
			<ns0:name>krasin@google.com</ns0:name><ns0:uri>/u/krasin@google.com/</ns0:uri></ns0:author><ns0:content type="html">David,

this is not about machine ABI, it's about bitcode ABI.

Consider the following bitcode generated by pnacl-gcc:

store %struct.baz %4, %struct.baz* %memtmp3
%5 = load %struct.baz* %memtmp3
call void @bar(%struct.baz* noalias sret %memtmp2, %struct.baz %5) nounwind

...
define void @bar(%struct.baz* noalias sret %agg.result, %struct.baz %x) nounwind {
entry:
  %x_addr = alloca %struct.baz, align 4
  %"alloca point" = bitcast i32 0 to i32
  store %struct.baz %x, %struct.baz* %x_addr
  %agg.result1 = bitcast %struct.baz* %agg.result to i8*
  %x_addr2 = bitcast %struct.baz* %x_addr to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32(i8* %agg.result1, i8* %x_addr2, i32 8, i32 4, i1 false)

The caller passes a structure, and callee immediately makes a copy. This is the implementation of passing structure by value on the bitcode level.

At the same time, clang uses byval parameter attribute which would be resolved in a copy on the translation phase:

call void @bar(%struct.baz* sret %tmp4, %struct.baz* byval %t)
...
define void @bar(%struct.baz* noalias sret %agg.result, %struct.baz* byval %x) nounwind {

so, it's the implementation of passing by value on the machine level.

Once translated to the machine code, there's no difference, but it's impossible to compile the definition of the function that accepts a struct argument by value with pnacl-gcc and use it from the source file that is compiled with Clang, because they would use different function signatures.

It's unclear if we want to use Clang and pnacl-gcc simultaneously, so that this compatibility is required.

If the plan is to consider Clang as experimental and deprecate pnacl-gcc once pnacl port is done, then this issue is a noop.
</ns0:content><ns0:updated>2011-08-30T00:25:03.000Z</ns0:updated><ns0:published>2011-08-30T00:25:03.000Z</ns0:published><ns2:updates /><ns0:title>Comment 2 by krasin@google.com</ns0:title><ns0:link href="http://code.google.com/p/nativeclient/issues/detail?id=2207#c2" rel="alternate" type="text/html" /><ns0:link href="https://code.google.com/feeds/issues/p/nativeclient/issues/2207/comments/full/2" rel="self" type="application/atom+xml" /></ns0:entry>