<ns0:entry xmlns:ns0="http://www.w3.org/2005/Atom" xmlns:ns1="http://schemas.google.com/g/2005" xmlns:ns2="http://schemas.google.com/projecthosting/issues/2009" ns1:etag="W/&quot;DEMHQn47eCl7ImA9WhRTEks.&quot;">
		<ns0:id>http://code.google.com/feeds/issues/p/nativeclient/issues/2235/comments/full/1</ns0:id><ns0:author>
			<ns0:name>mseaborn@chromium.org</ns0:name><ns0:uri>/u/mseaborn@chromium.org/</ns0:uri></ns0:author><ns0:content type="html">I investigated stack unwinding further in the context of issue 2237.

For x86-64 Linux, there should not be a problem, at least for the stack unwinding done by C++ exceptions (which shouldn't occur inside NaCl syscalls) and pthread_exit() (which does occur inside NaCl syscalls).  Stack unwinding uses runtime DWARF info.  If the unwinder hits an address for which there is no DWARF unwind info (such as the return address in NaClSyscallSeg), it will stop.  Compilers can use any register as a frame pointer - %rbp is not special, so there is not a default for unwinding a frame.</ns0:content><ns0:updated>2011-11-02T20:40:33.000Z</ns0:updated><ns0:published>2011-11-02T20:40:33.000Z</ns0:published><ns2:updates /><ns0:title>Comment 1 by mseaborn@chromium.org</ns0:title><ns0:link href="http://code.google.com/p/nativeclient/issues/detail?id=2235#c1" rel="alternate" type="text/html" /><ns0:link href="https://code.google.com/feeds/issues/p/nativeclient/issues/2235/comments/full/1" rel="self" type="application/atom+xml" /></ns0:entry>