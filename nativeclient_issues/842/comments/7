<ns0:entry xmlns:ns0="http://www.w3.org/2005/Atom" xmlns:ns1="http://schemas.google.com/g/2005" xmlns:ns2="http://schemas.google.com/projecthosting/issues/2009" ns1:etag="W/&quot;C0YFRn47eCl7ImA9Wx9VGE4.&quot;">
		<ns0:id>http://code.google.com/feeds/issues/p/nativeclient/issues/842/comments/full/7</ns0:id><ns0:author>
			<ns0:name>pdox%goo...@gtempaccount.com</ns0:name><ns0:uri>/u/104735739662288482898/</ns0:uri></ns0:author><ns0:content type="html">llvm can directly expand intrinsics in certain cases (for example, it can expand memset when the size argument is constant), but in many cases it relies on library calls as an implementation.

Aggressive optimizations can generate calls to memset() with variable size, even for elementary operations like array initialization.

One possible solution to consider is to provide LLVM with the ability to emit a full implementation of the intrinsics, so that it is always possible to handle intrinsics without calling the library functions. However, this would effectively inline all calls to memset/memcpy/etc. Code size would be increased.
</ns0:content><ns0:updated>2011-02-04T14:51:57.000Z</ns0:updated><ns0:published>2011-02-04T14:51:57.000Z</ns0:published><ns2:updates /><ns0:title>Comment 7 by pdox%goo...@gtempaccount.com</ns0:title><ns0:link href="http://code.google.com/p/nativeclient/issues/detail?id=842#c7" rel="alternate" type="text/html" /><ns0:link href="https://code.google.com/feeds/issues/p/nativeclient/issues/842/comments/full/7" rel="self" type="application/atom+xml" /></ns0:entry>