<ns0:entry xmlns:ns0="http://www.w3.org/2005/Atom" xmlns:ns1="http://schemas.google.com/g/2005" xmlns:ns2="http://schemas.google.com/projecthosting/issues/2009" ns1:etag="W/&quot;D0MMQ347eCl7ImA9WhVXE04.&quot;">
		<ns0:id>http://code.google.com/feeds/issues/p/nativeclient/issues/1730/comments/full/7</ns0:id><ns0:author>
			<ns0:name>mcgra...@chromium.org</ns0:name><ns0:uri>/u/109286297231979736865/</ns0:uri></ns0:author><ns0:content type="html">The behavior expected by the usual protocol is that the PC is after the breakpoint instruction on stop, just as the hardware leaves it.  So I think the really right answer is to make the debug stub compensate for the Windows weirdness and leave the PC after the int3 in all cases.  That is, for the case where GDB sent a memory-modifying command to insert the breakpoint.  For Z packets I'm not sure what the usual behavior is, but we should make our debug stub behave like others do in all the cases it supports.

I don't really understand how #2 relates to the underlying problem.</ns0:content><ns0:updated>2012-04-13T16:44:42.000Z</ns0:updated><ns0:published>2012-04-13T16:44:42.000Z</ns0:published><ns2:updates /><ns0:title>Comment 7 by mcgra...@chromium.org</ns0:title><ns0:link href="http://code.google.com/p/nativeclient/issues/detail?id=1730#c7" rel="alternate" type="text/html" /><ns0:link href="https://code.google.com/feeds/issues/p/nativeclient/issues/1730/comments/full/7" rel="self" type="application/atom+xml" /></ns0:entry>