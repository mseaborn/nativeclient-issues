<ns0:entry xmlns:ns0="http://www.w3.org/2005/Atom" xmlns:ns1="http://schemas.google.com/g/2005" xmlns:ns2="http://schemas.google.com/projecthosting/issues/2009" ns1:etag="W/&quot;DEAEQ347eCl7ImA9Wx5RFkQ.&quot;">
		<ns0:id>http://code.google.com/feeds/issues/p/nativeclient/issues/839/comments/full/9</ns0:id><ns0:author>
			<ns0:name>b...@google.com</ns0:name><ns0:uri>/u/105821748722532785568/</ns0:uri></ns0:author><ns0:content type="html">syscalls that succeed should never set errno to zero.  that would be an error.

this bug is in untrusted code -- libnacl wrapper code.

there appears to be some naming issues.  i'm not sure from what are you getting the expected semantics of sysbrk.  afaict, sysbrk is the raw syscall version of brk, though neither sehr nor i can remember why it's called sysbrk, nor why we have __NaClBrk and no brk in src/untrusted/nacl/sbrk.c.  sysbrk is not supposed to set errno.  its error indication is in-line -- by returning the current break value.  brk should be the libc wrapper interface, and it should set errno if the raw syscall indicates failure.

so, i think we may have a bug here and need to figure out why we don't have brk (or if newlib supplies it).  our __NaClBrk appears to do most of what brk is supposed to do, but does not set errno either.  however, i think your test is also bogus, since the raw syscall was never supposed to set errno in the first place.</ns0:content><ns0:updated>2010-08-25T00:38:22.000Z</ns0:updated><ns0:published>2010-08-25T00:38:22.000Z</ns0:published><ns2:updates /><ns0:title>Comment 9 by b...@google.com</ns0:title><ns0:link href="http://code.google.com/p/nativeclient/issues/detail?id=839#c9" rel="alternate" type="text/html" /><ns0:link href="https://code.google.com/feeds/issues/p/nativeclient/issues/839/comments/full/9" rel="self" type="application/atom+xml" /></ns0:entry>