<ns0:entry xmlns:ns0="http://www.w3.org/2005/Atom" xmlns:ns1="http://schemas.google.com/g/2005" xmlns:ns2="http://schemas.google.com/projecthosting/issues/2009" ns1:etag="W/&quot;CEEASH47eCl7ImA9WhZVE0g.&quot;">
		<ns0:id>http://code.google.com/feeds/issues/p/nativeclient/issues/1848/comments/full/1</ns0:id><ns0:author>
			<ns0:name>mseaborn@chromium.org</ns0:name><ns0:uri>/u/mseaborn@chromium.org/</ns0:uri></ns0:author><ns0:content type="html">There is another way we could fix this:  If NaCl ever gains the ability to safely handle memory faults in untrusted code, we could detect when a fault was caused by a page being temporarily unmapped and resume the code that faulted after the mmap() syscall has completed.

There is a complication.  NaCl system calls can also access untrusted pages that might be temporarily unmapped.  These memory accesses would also have to be restarted if they fault.  This might not be practical for buffers that are passed to Windows system calls (e.g. inside NaCl's read() or write()), so it might be necessary for sel_ldr to copy these buffers in order to handle this case fully.  Prompt, non-blocking syscalls are easier to handle, though: they could share a common lock with mmap().</ns0:content><ns0:updated>2011-05-25T19:44:09.000Z</ns0:updated><ns0:published>2011-05-25T19:44:09.000Z</ns0:published><ns2:updates /><ns0:title>Comment 1 by mseaborn@chromium.org</ns0:title><ns0:link href="http://code.google.com/p/nativeclient/issues/detail?id=1848#c1" rel="alternate" type="text/html" /><ns0:link href="https://code.google.com/feeds/issues/p/nativeclient/issues/1848/comments/full/1" rel="self" type="application/atom+xml" /></ns0:entry>