<ns0:entry xmlns:ns0="http://www.w3.org/2005/Atom" xmlns:ns1="http://schemas.google.com/g/2005" xmlns:ns2="http://schemas.google.com/projecthosting/issues/2009" ns1:etag="W/&quot;D0ECSX47eCl7ImA9WhdWE04.&quot;">
		<ns0:id>http://code.google.com/feeds/issues/p/nativeclient/issues/2232/comments/full/4</ns0:id><ns0:author>
			<ns0:name>mcgra...@chromium.org</ns0:name><ns0:uri>/u/109286297231979736865/</ns0:uri></ns0:author><ns0:content type="html">Ok, well this is nothing new and nothing specific to IRT.
Thread creation takes an initial PC and an initial SP.
Despite some of the implicit documentation of the use in the sources, it's not a "function pointer"--that would be something called with the C ABI.  It's an initial PC, and the caller of thread_create is responsible for arranging that what that PC expects and what the initial SP are match.  What is new with the IRT is that the user-supplied initial PC is not actually the initial PC (irt_start_thread is).  So it's closer to being a function pointer in the sense that it really is called from C.  But since its caller is a C function whose entry point is used as the initial PC, the requirement for alignment of the initial SP is still what the requirement would be for the user's supplied initial PC being the true initial PC.

We could either just document this, or we could make irt_start_thread resilient to stack alignment by defining it with the force_align_arg_pointer attribute.</ns0:content><ns0:updated>2011-09-06T19:01:08.000Z</ns0:updated><ns0:published>2011-09-06T19:01:08.000Z</ns0:published><ns2:updates /><ns0:title>Comment 4 by mcgra...@chromium.org</ns0:title><ns0:link href="http://code.google.com/p/nativeclient/issues/detail?id=2232#c4" rel="alternate" type="text/html" /><ns0:link href="https://code.google.com/feeds/issues/p/nativeclient/issues/2232/comments/full/4" rel="self" type="application/atom+xml" /></ns0:entry>