<ns0:entry xmlns:ns0="http://www.w3.org/2005/Atom" xmlns:ns1="http://schemas.google.com/g/2005" xmlns:ns2="http://schemas.google.com/projecthosting/issues/2009" ns1:etag="W/&quot;D0EFSX47eCl7ImA9WhJQEEo.&quot;">
		<ns0:id>http://code.google.com/feeds/issues/p/nativeclient/issues/full/2891</ns0:id><ns0:author>
			<ns0:name>mcgra...@chromium.org</ns0:name><ns0:uri>/u/109286297231979736865/</ns0:uri></ns0:author><ns0:content type="html">The compiler likes to generate code that computes ptr+BIGCONSTANT in a register, and then uses e.g. &amp;quot;ldr r1,[r2, #-BIGCONSTANT]&amp;quot;.  When the pointer computed is a stack address, it can be close to the 1G limit, such that ptr+BIGCONSTANT is &amp;gt;= 1G.  Then when we sandbox the base register, we can wind up with it becoming zero or something close to zero, so the actual memory access tries to use 0-BIGCONSTANT or some such thing.

It may be infeasible to prevent the compiler from doing this, and even if doable it is probably a pessimization in many cases, since the compiler does this trick so that it can use the limited range of immediate offsets in load and store instructions to best effect, avoiding more arithmetic instructions and/or register pressure.

The simple workaround for this issue is just to ensure that no valid address is ever within the immediate range (12 bits signed, I think) of the top of the untrusted address space.  That is, just start the stack a bit lower, like a page lower (or perhaps 64k lower just because).</ns0:content><ns0:updated>2012-07-23T20:33:38.000Z</ns0:updated><ns0:published>2012-07-03T23:32:29.000Z</ns0:published><ns2:status>Duplicate</ns2:status><ns2:owner>
			<ns2:uri>/u/109286297231979736865/</ns2:uri><ns2:username>mcgra...@chromium.org</ns2:username></ns2:owner><ns2:cc>
			<ns2:uri>/u/108394971971967673680/</ns2:uri><ns2:username>s...@google.com</ns2:username></ns2:cc><ns2:cc>
			<ns2:uri>/u/105821748722532785568/</ns2:uri><ns2:username>b...@google.com</ns2:username></ns2:cc><ns2:state>closed</ns2:state><ns0:title>start the stack at least 2k below the sandbox limit for ARM</ns0:title><ns2:label>Type-Defect</ns2:label><ns2:label>Mstone-</ns2:label><ns2:label>Pri-2</ns2:label><ns2:label>Component-TCB</ns2:label><ns2:label>OS-All</ns2:label><ns2:label>Arch-ARM</ns2:label><ns0:link href="http://code.google.com/feeds/issues/p/nativeclient/issues/2891/comments/full" rel="replies" type="application/atom+xml" /><ns0:link href="http://code.google.com/p/nativeclient/issues/detail?id=2891" rel="alternate" type="text/html" /><ns0:link href="https://code.google.com/feeds/issues/p/nativeclient/issues/full/2891" rel="self" type="application/atom+xml" /><ns2:stars>1</ns2:stars><ns2:closedDate>2012-07-23T20:33:38.000Z</ns2:closedDate><ns2:id>2891</ns2:id><ns2:mergedInto>
			<ns2:id>2909</ns2:id><ns2:project>nativeclient</ns2:project></ns2:mergedInto></ns0:entry>