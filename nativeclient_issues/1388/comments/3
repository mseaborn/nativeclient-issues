<ns0:entry xmlns:ns0="http://www.w3.org/2005/Atom" xmlns:ns1="http://schemas.google.com/g/2005" xmlns:ns2="http://schemas.google.com/projecthosting/issues/2009" ns1:etag="W/&quot;CEMFRH47eCl7ImA9Wx9VF0o.&quot;">
		<ns0:id>http://code.google.com/feeds/issues/p/nativeclient/issues/1388/comments/full/3</ns0:id><ns0:author>
			<ns0:name>mseaborn@chromium.org</ns0:name><ns0:uri>/u/mseaborn@chromium.org/</ns0:uri></ns0:author><ns0:content type="html">I see what you mean.  Crikey, that is scary.  Do compilers really do this?  This would be an issue for kernels too, so do they use "volatile" for this too?  This would also be an issue for mutually distrusting userland programs that share data via shared memory.

This problem is an argument for having a pair of functions for copying data to and from untrusted address space instead of open coding a NaClUserToSysAddrRange() call followed by memory access.  Also see point 5 on http://lackingrhoticity.blogspot.com/2010/01/why-system-calls-should-be-message.html.</ns0:content><ns0:updated>2011-02-03T22:33:35.000Z</ns0:updated><ns0:published>2011-02-03T22:33:35.000Z</ns0:published><ns2:updates /><ns0:title>Comment 3 by mseaborn@chromium.org</ns0:title><ns0:link href="http://code.google.com/p/nativeclient/issues/detail?id=1388#c3" rel="alternate" type="text/html" /><ns0:link href="https://code.google.com/feeds/issues/p/nativeclient/issues/1388/comments/full/3" rel="self" type="application/atom+xml" /></ns0:entry>