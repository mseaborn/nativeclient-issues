<ns0:entry xmlns:ns0="http://www.w3.org/2005/Atom" xmlns:ns1="http://schemas.google.com/g/2005" xmlns:ns2="http://schemas.google.com/projecthosting/issues/2009" ns1:etag="W/&quot;CEcFQH47eCl7ImA9Wx9VF0U.&quot;">
		<ns0:id>http://code.google.com/feeds/issues/p/nativeclient/issues/1388/comments/full/4</ns0:id><ns0:author>
			<ns0:name>b...@google.com</ns0:name><ns0:uri>/u/105821748722532785568/</ns0:uri></ns0:author><ns0:content type="html">compilers are not optimized for (optimizing) kernel code, or for situations where different threads operate at different levels of trust.  i don't know how often compiler do this, but certainly the language semantics allow them to.  often kernels want to be compiled -O0 to avoid optimizations that might cause problems; i'm not sure if the problems include the one that i pointed out, but i think so.

iirc, bsd/early mach had copyin and copyout.  we probably should move in that direction, though the number of such accesses is still rather small for us and still tractable.  note that copyin/copyout will still need volatile declarations, since a compiler that does function inlining and whole program optimization could (theoretically) still make the same optimization.</ns0:content><ns0:updated>2011-02-04T01:13:31.000Z</ns0:updated><ns0:published>2011-02-04T01:13:31.000Z</ns0:published><ns2:updates /><ns0:title>Comment 4 by b...@google.com</ns0:title><ns0:link href="http://code.google.com/p/nativeclient/issues/detail?id=1388#c4" rel="alternate" type="text/html" /><ns0:link href="https://code.google.com/feeds/issues/p/nativeclient/issues/1388/comments/full/4" rel="self" type="application/atom+xml" /></ns0:entry>