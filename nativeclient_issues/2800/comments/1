<ns0:entry xmlns:ns0="http://www.w3.org/2005/Atom" xmlns:ns1="http://schemas.google.com/g/2005" xmlns:ns2="http://schemas.google.com/projecthosting/issues/2009" ns1:etag="W/&quot;DUUDRX47eCl7ImA9WhVUFk4.&quot;">
		<ns0:id>http://code.google.com/feeds/issues/p/nativeclient/issues/2800/comments/full/1</ns0:id><ns0:author>
			<ns0:name>b...@google.com</ns0:name><ns0:uri>/u/105821748722532785568/</ns0:uri></ns0:author><ns0:content type="html">This was a false alarm.  The NaClDescMutex (and NaClDescCondVar) classes wrap NaClIntrMutex (and NaClIntrCondVar) classes and not NaClMutex (and NaClCondVar) directly.  While NaClIntrMutex was originally intended to permit mutexes to be interrupted so that low-level code code handle address-space move (for Windows, due to the mmap hole race condition), it also has the side-effect of never holding a low-level NaClMutex object locked for very long.  Instead, it merely sets a flag that specifies the lock state -- which can include an "interrupted" state as well as locked / available -- so that low-level locks are never held across threads.

The upshot is that NaClIntrMutex is already the more complex object that avoided undefined behavior.  It does it in a slightly different way in that it doesn't keep track of which thread holds the lock, but that doesn't matter.</ns0:content><ns0:updated>2012-05-21T21:54:34.000Z</ns0:updated><ns0:published>2012-05-21T21:54:34.000Z</ns0:published><ns2:updates>
			<ns2:status>Invalid</ns2:status></ns2:updates><ns0:title>Comment 1 by b...@google.com</ns0:title><ns0:link href="http://code.google.com/p/nativeclient/issues/detail?id=2800#c1" rel="alternate" type="text/html" /><ns0:link href="https://code.google.com/feeds/issues/p/nativeclient/issues/2800/comments/full/1" rel="self" type="application/atom+xml" /></ns0:entry>